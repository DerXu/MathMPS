(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



<<MPS.m


<<parameters.m


timestamp=DateString[{"Year","Month","Day", "Hour","Minute","Hour24","Minute","Second"}];


parameterList={
{"Bond Dimension: ",bond},
{"Chain Length: ",length},
{"Interaction Range: ",intrange},
{"Initial mu: ",\[Mu]ini},
{"Delta mu: ",\[Delta]\[Mu]},
{"mu Points: ",\[Mu]points},
{"Initial J: ",Jini},
{"Delta J: ",\[Delta]J},
{"J Points: ",Jpoints},
{"Date: ",DateString[]},
{"Machine: ",$MachineName}
};


Export[outputfile<>"."<>timestamp<>".info",parameterList,"Table"];


(* en\[Delta]J=(Jend-Jini)/Jpoints;
\[Delta]\[Mu]=(\[Mu]end-\[Mu]ini)/\[Mu]points;*)


Do[
\[Mu]=n\[Mu]*\[Delta]\[Mu]+\[Mu]ini;
(* Initialize MPS at product state, good for J=0 *)
mymps=MPSProductState[length,Bond->bond];
MPSNormalize[mymps];
Do[
(* compute parameters and Hamiltonian *)
J=nJ*\[Delta]J+Jini;
HMatrix=Table[Table[Piecewise[{{If[\[Alpha]==3,\[Mu],0.0],n==m},{If[\[Alpha]==3,1.0,J]/Abs[n-m]^3,Abs[n-m]<=intrange}}],{n,1,length},{m,1,length}],{\[Alpha],1,3}];
(* Check if previous file exists *)
If[Length[FileNames[inputfile<>".mu."<>ToString[\[Mu]]<>".J."<>ToString[J]<>".MPSz"]]!=0,tempmps=MPSRead[inputfile<>".mu."<>ToString[\[Mu]]<>".J."<>ToString[J]<>".MPSz"];
mymps=MPSExpandBond[tempmps,bond];
];
(* Compute ground state *)
Print[ToString[MemoryInUse[]/(1024 1024.)]<>"MB used before link"];
{tim,energ}=AbsoluteTiming[MPSMinimizeEnergy[mymps,HMatrix,Verbose->False,InteractionRange->intrange]];
Pause[0.1];
Print[ToString[MemoryInUse[]/(1024 1024.)]<>"MB used after link"];
(* Print out status *)
Print["(J,mu):"<>ToString[{J,\[Mu]}]<>" -- Last time: "<>ToString[tim]<>" -- energy: "<>ToString[Last[energ]]<>", "<>ToString[MemoryInUse[]/(1024 1024.)]<>"MB used"];
(* Save and continue *)
MPSSave[mymps,outputfile<>".mu."<>ToString[\[Mu]]<>".J."<>ToString[J]]; 
,{nJ,0,Jpoints,1}];
,{n\[Mu],0,\[Mu]points,1}];
Print["Finished all"];
