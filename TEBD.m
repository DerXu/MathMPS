(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



TOLERANCE=10^(-10); (* This is the tolerance of PseudoInverse *)


Options[TEBDProductState]={Spin->2,BondDimension->20,Type->{"Random",{}}};
TEBDProductState[numSites_,OptionsPattern[]]:=Module[{\[CapitalGamma]=Array[0&,{numSites}],\[Lambda]=Array[0&,{numSites}],tempType=OptionValue[Type],type,phaseList,spin=OptionValue[Spin],\[Chi]=OptionValue[BondDimension]},
{type,phaseList}=tempType;
Switch[type,
"Specified",
If[Dimensions[phaseList]!={numSites,2},Print["TEBDProductState called with wrong list of phases."];Abort[]],
"Identity",
phaseList=Table[{0.0,0.0},{k,1,numSites}];,
"Random",
phaseList=RandomReal[{0,2\[Pi]},{numSites,2}];
];
Table[{
Table[SparseArray[{{i_,j_}/;(i==j==1)->Chop[(2-n)Cos[1.0 phaseList[[k,1]]]+(n-1)Exp[I phaseList[[k,2]]]Sin[1.0 phaseList[[k,1]]]]},{\[Chi],\[Chi]}],{n,1,spin}],
SparseArray[{i_}/;i<=1->1.0 ,{\[Chi]}]},
{k,1,numSites}]
]


SetAttributes[TEBDSave,HoldFirst];
TEBDSave[TEBD_,filename_]:=Module[{numSites,spin,\[Chi]},
numSites=Length[TEBD];
spin=Length[TEBD[[1,1]]];
\[Chi]=Length[TEBD[[1,1,1]]];
Export[filename<>".info",{numSites,spin,\[Chi]},"Table"];
Do[
Do[
Export[filename<>".G."<>ToString[n]<>"."<>ToString[s]<>".dat",TEBD[[n,1,s]],"Table"]
,{s,1,spin}];
Export[filename<>".L."<>ToString[n]<>".dat",TEBD[[n,2]],"Table"];
,{n,1,numSites}]
]


SetAttributes[TEBDRead,HoldFirst];
TEBDRead[TEBD_,filename_]:=Module[{numSites,spin,\[Chi],info},
info=Flatten[Import[filename<>".info","Table"]];
{numSites,spin,\[Chi]}=info;
TEBD=TEBDProductState[numSites,Spin->spin,BondDimension->\[Chi]];
Do[
TEBD[[n,1]]=SparseArray[Table[
Import[filename<>".G."<>ToString[n]<>"."<>ToString[s]<>".dat","Table"]
,{s,1,spin}]];
TEBD[[n,2]]=SparseArray[Flatten[Import[filename<>".L."<>ToString[n]<>".dat","Table"]]];
,{n,1,numSites}]
]


Swap={{1,0,0,0},{0,0,1,0},{0,1,0,0},{0,0,0,1}};


SetAttributes[TEBD2QGate,HoldFirst];
TEBD2QGate[TEBD_,leftSite_,H_]:=Module[{\[Chi],\[Chi]R,\[Chi]L,Hint,\[Lambda]LD,\[Lambda]CD,\[Lambda]RD,\[CapitalSigma],X,YT,\[Lambda]temp,\[Lambda]RDi,\[Lambda]LDi,norm,numSites,rightSite,spin},
(*   Print[step=0.1,\[Lambda]L,\[Lambda]C,\[Lambda]R]; Preliminary: prepare matrices for fast products *)
numSites=Length[TEBD];
rightSite=leftSite+1;
If[(1<=leftSite<numSites)!=True,Print["TEBD2QGate called with wrong site parameter."];Abort[]];
{spin,\[Chi]L,\[Chi]R}=Dimensions[TEBD[[leftSite,1]]];
\[Chi]=Max[\[Chi]R,\[Chi]L];
If[Dimensions[H]!={spin^2,spin^2},Print["TEBD2QGate called with wrong operator dimensions."];Abort[]];
Hint=((Partition[#,spin]&/@H));
If[leftSite==1,
\[Lambda]LD=SparseArray[{i_,j_}/;i==j==1->1.0 ,{\[Chi],\[Chi]}];,
\[Lambda]LD=SparseArray[DiagonalMatrix[TEBD[[leftSite-1,2]]]];
];
\[Lambda]CD=SparseArray[DiagonalMatrix[TEBD[[leftSite,2]]]];
\[Lambda]RD=SparseArray[DiagonalMatrix[TEBD[[rightSite,2]]]];
(**O Print["Check 2-1,"];Print[Dimensions[#]&/@{\[Lambda]RD,\[Lambda]CD,TEBD[[leftSite,1]],TEBD[[rightSite,1]]}];DD**)
\[CapitalSigma]=Flatten[Flatten[\[Lambda]LD.Transpose[TEBD[[leftSite,1]],{2,1,3}].\[Lambda]CD.Transpose[TEBD[[rightSite,1]],{2,1,3}].\[Lambda]RD,{{1},{4},{2,3}}].Hint,{{3,1},{4,2}}];
{X,\[Lambda]temp,YT}=SingularValueDecomposition[\[CapitalSigma]]; 
(**O Print["Check 2-1B: "<>ToString[leftSite]<>", "<>ToString[Dimensions[#]&/@{X,\[Lambda]temp,YT}]];DD**)
\[Lambda]CD=(PadRight[Diagonal[\[Lambda]temp],\[Chi]]); 
norm=Total[\[Lambda]CD^2];
TEBD[[leftSite,2]]=\[Lambda]CD/Sqrt[norm];
(**O Print["Check 2-2"];DD**)
\[Lambda]LDi=SparseArray[PseudoInverse[Normal[\[Lambda]LD],Tolerance->TOLERANCE]];
TEBD[[leftSite,1]]=SparseArray[Chop[(\[Lambda]LDi.#&)/@(Partition[X,{\[Chi],\[Chi]}][[All,1]])]];
(**O Print["Check 2-3"];DD**)
(**O Print["Check 2-3 B: site "<>ToString[rightSite]<>", "<>ToString[Dimensions[#]&/@{YT,(Partition[ConjugateTranspose[YT],{\[Chi],\[Chi]}][[1,All]]),Transpose[{PadRight[Conjugate[#],\[Chi]]}]&/@YT}]];DD**)
\[Lambda]RDi=SparseArray[PseudoInverse[Normal[\[Lambda]RD],Tolerance->TOLERANCE]];
TEBD[[rightSite,1]]=SparseArray[Chop[(#.\[Lambda]RDi&)/@(Partition[ConjugateTranspose[YT],{\[Chi],\[Chi]}][[1,All]])]];
1-norm
]


SetAttributes[TEBDGate,HoldFirst];
TEBDGate[TEBD_,SiteOperator_]:=Module[{error,numSites,numOfSwaps,ActualLeft,ActualRight,leftSite,rightSite,H},
(*   Print[step=0.1,\[Lambda]L,\[Lambda]C,\[Lambda]R]; Preliminary: prepare matrices for fast products *)
numSites=Length[TEBD];
H=SiteOperator[[1]];
leftSite=SiteOperator[[2]];
rightSite=SiteOperator[[3]];
If[!(1<=leftSite<=numSites)||!(1<=rightSite<=numSites),Print["TEBDGate[left,right] called with wrong site parameter:",leftSite,",",rightSite];Abort[]];
error=0;
If[leftSite==rightSite,
(* Equal sites *)
error=TEBD1QGate[TEBD,leftSite,H];
, 
(* Different sites *)
ActualLeft=Min[leftSite,rightSite];
ActualRight=Max[leftSite,rightSite];
numOfSwaps=ActualRight-ActualLeft-If[leftSite<rightSite,1,0];
error=0;
Do[error+=TEBD2QGate[TEBD,ActualRight-n,Swap],{n,1,numOfSwaps,1}];
error+=TEBD2QGate[TEBD,ActualLeft,H];
Do[error+=TEBD2QGate[TEBD,ActualRight-n,Swap],{n,numOfSwaps,1,-1}];
];
error
]


SetAttributes[TEBD3QGate,HoldFirst];
TEBD3QGate[TEBD_,centerSite_,H_]:=Module[{spin,\[Chi],\[Chi]R,\[Chi]L,\[Lambda]LD,\[Lambda]1D,\[Lambda]2D,\[Lambda]RD,\[CapitalSigma],X,YT,\[Lambda]temp,\[Lambda]RDi,\[Lambda]LDi,\[Lambda]1Di,norm1,norm2,numSites,Hint,leftSite,rightSite},
 (*  Print[step=0];  Preliminary: prepare matrices for fast products *)
leftSite=centerSite-1;
rightSite=centerSite+1;
numSites=Length[TEBD];
If[(1<centerSite<numSites)!=True,Print["TEBD3QGate called with wrong site,"<>ToString[centerSite]];Abort[]];
{spin,\[Chi]L,\[Chi]R}=Dimensions[TEBD[[leftSite,1]]];
\[Chi]=Max[\[Chi]R,\[Chi]L];
If[Dimensions[H]!={spin^3,spin^3},Print["TEBD3QGate called with wrong operator dimensions."];Abort[]];
Hint=(Partition[#,spin]&/@(Partition[#,spin]&/@H));
If[leftSite==1,
\[Lambda]LD=SparseArray[{i_,j_}/;i==j==1->1.0 ,{\[Chi],\[Chi]}];,
\[Lambda]LD=SparseArray[DiagonalMatrix[TEBD[[leftSite-1,2]]]];
];
\[Lambda]1D=SparseArray[DiagonalMatrix[TEBD[[leftSite,2]]]];
\[Lambda]2D=SparseArray[DiagonalMatrix[TEBD[[centerSite,2]]]];
\[Lambda]RD=SparseArray[DiagonalMatrix[TEBD[[rightSite,2]]]];
(**O Print["Check 3-1"];DD**)
(* First make 3 spin matrix  *)
\[CapitalSigma]=Flatten[Flatten[\[Lambda]LD.Transpose[TEBD[[leftSite,1]],{2,1,3}].\[Lambda]1D.Transpose[TEBD[[centerSite,1]],{2,1,3}].\[Lambda]2D.Transpose[TEBD[[rightSite,1]],{2,1,3}].\[Lambda]RD,{{1},{5},{2,3,4}}].Hint,{{3,1},{4,5,2}}];
(*  Perform SVD of the three spin matrix as 1-2 spins *)
{X,\[Lambda]temp,YT}=SingularValueDecomposition[\[CapitalSigma]]; 
\[Lambda]temp=(PadRight[Diagonal[\[Lambda]temp],\[Chi]]); (* Truncated values *)
norm1=Total[\[Lambda]temp^2];
TEBD[[leftSite,2]]=SparseArray[\[Lambda]temp/Sqrt[norm1]];
\[Lambda]1D=DiagonalMatrix[TEBD[[leftSite,2]]];
(* Extract the tensors of the left spin *)
(**O Print["Check 3-2"];DD**)
\[Lambda]LDi=SparseArray[PseudoInverse[Normal[\[Lambda]LD],Tolerance->TOLERANCE]];
TEBD[[leftSite,1]]=SparseArray[Chop[(\[Lambda]LDi.#&)/@(Partition[X,{\[Chi],\[Chi]}][[All,1]])]];
(* Now rearrange right matrix to represent 2 spins as 1-1, multiplying before by the new \[Lambda]1 *)
(**O Print["Check 3-3"];DD**)
\[CapitalSigma]=Flatten[\[Lambda]1D.Transpose[Partition[Partition[ConjugateTranspose[YT],{\[Chi],\[Chi]}][[1,All]],spin],{2,3,1,4}],{{2,1},{3,4}}];
(* And get the SVD as a normal case *)
{X,\[Lambda]temp,YT}=SingularValueDecomposition[\[CapitalSigma]]; 
(**O Print[ToString[Dimensions[#]&/@{X,\[Lambda]temp,YT}]];DD**)
\[Lambda]temp=(PadRight[Diagonal[\[Lambda]temp],\[Chi]]); (* Truncated values *)
norm2=Total[\[Lambda]temp^2];
TEBD[[centerSite,2]]=SparseArray[\[Lambda]temp/Sqrt[norm2]];
(* The center tensor we obtain taking out \[Lambda]1 *) 
\[Lambda]1Di=SparseArray[PseudoInverse[Normal[\[Lambda]1D],Tolerance->TOLERANCE]];
(**O Print["Check 3-4"];DD**)
TEBD[[centerSite,1]]=SparseArray[Chop[(\[Lambda]1Di.#&)/@(Partition[X,{\[Chi],\[Chi]}][[All,1]])]];
(* The right tensor needs the inverse right lambda to fit *)
(**O Print["Check 3-5"];DD**)
(**O Print["Check 3-5 B: site "<>ToString[rightSite]<>", "<>ToString[Dimensions[#]&/@{YT,(Partition[ConjugateTranspose[YT],{\[Chi],\[Chi]}][[1,All]]),Transpose[{PadRight[Conjugate[#],\[Chi]]}]&/@YT}]];DD**)
\[Lambda]RDi=SparseArray[PseudoInverse[Normal[\[Lambda]RD],Tolerance->TOLERANCE]];
TEBD[[rightSite,1]]=SparseArray[Chop[(#.\[Lambda]RDi&)/@(Partition[ConjugateTranspose[YT],{\[Chi],\[Chi]}][[1,All]])]];
2-norm1-norm2
]


SetAttributes[TEBD4QGate,HoldFirst];
TEBD4QGate[TEBD_,leftSite_,H_]:=Module[{spin,\[Chi],\[Chi]R,\[Chi]L,\[Lambda]LD,\[Lambda]1D,\[Lambda]2D,\[Lambda]3D,\[Lambda]2Di,\[Lambda]RD,\[CapitalSigma],X,YT,\[Lambda]temp,\[Lambda]RDi,\[Lambda]LDi,\[Lambda]1Di,norm1,norm2,norm3,numSites,Hint,centerSite1,centerSite2,rightSite},
 (*  Print[step=0];  Preliminary: prepare matrices for fast products *)
centerSite1=leftSite+1;
centerSite2=leftSite+2;
rightSite=leftSite+3;
numSites=Length[TEBD];
If[(1<=leftSite<rightSite<=numSites)!=True,Print["TEBD4QGate called with wrong site,"<>ToString[leftSite]];Abort[]];
{spin,\[Chi],\[Chi]R}=Dimensions[TEBD[[centerSite1,1]]];
If[Dimensions[H]!={spin^4,spin^4},Print["TEBD4QGate called with wrong operator dimensions."];Abort[]];
Hint=Partition[#,spin]&/@(Partition[#,spin]&/@(Partition[#,spin]&/@H));
If[leftSite==1,
\[Lambda]LD=SparseArray[{i_,j_}/;i==j==1->1.0 ,{\[Chi],\[Chi]}];,
\[Lambda]LD=SparseArray[DiagonalMatrix[TEBD[[leftSite-1,2]]]];
];
\[Lambda]1D=SparseArray[DiagonalMatrix[TEBD[[leftSite,2]]]];
\[Lambda]2D=SparseArray[DiagonalMatrix[TEBD[[centerSite1,2]]]];
\[Lambda]3D=SparseArray[DiagonalMatrix[TEBD[[centerSite2,2]]]];
\[Lambda]RD=SparseArray[DiagonalMatrix[TEBD[[rightSite,2]]]];
(**O Print["Check 3-1"];DD**)
(* First make 3 spin matrix  *)
\[CapitalSigma]=Flatten[Flatten[\[Lambda]LD.Transpose[TEBD[[leftSite,1]],{2,1,3}].\[Lambda]1D.Transpose[TEBD[[centerSite1,1]],{2,1,3}].\[Lambda]2D.Transpose[TEBD[[centerSite2,1]],{2,1,3}].\[Lambda]3D.Transpose[TEBD[[rightSite,1]],{2,1,3}].\[Lambda]RD,{{1},{6},{2,3,4,5}}].Hint,{{3,1},{4,5,2}}];
(*  Perform SVD of the three spin matrix as 1-2 spins *)
{X,\[Lambda]temp,YT}=SingularValueDecomposition[\[CapitalSigma]]; 
\[Lambda]temp=(PadRight[Diagonal[\[Lambda]temp],\[Chi]]); (* Truncated values *)
norm1=Total[\[Lambda]temp^2];
TEBD[[leftSite,2]]=SparseArray[\[Lambda]temp/Sqrt[norm1]];
\[Lambda]1D=DiagonalMatrix[TEBD[[leftSite,2]]];
(* Extract the tensors of the left spin *)
(**O Print["Check 3-2"];DD**)
\[Lambda]LDi=SparseArray[PseudoInverse[Normal[\[Lambda]LD],Tolerance->TOLERANCE]];
TEBD[[leftSite,1]]=SparseArray[Chop[(\[Lambda]LDi.#&)/@(Partition[X,{\[Chi],\[Chi]}][[All,1]])]];
(* Now rearrange right matrix to represent 2 spins as 1-1, multiplying before by the new \[Lambda]1 *)
(**O Print["Check 3-3"];DD**)
\[CapitalSigma]=Flatten[\[Lambda]1D.Transpose[Partition[Partition[ConjugateTranspose[YT],{\[Chi],spin^2 \[Chi]}][[1,All]],spin],{2,1,3}],{{2,1},{3}}];
(* And get the SVD as a normal case *)
{X,\[Lambda]temp,YT}=SingularValueDecomposition[\[CapitalSigma]]; 
(**O Print[ToString[Dimensions[#]&/@{X,\[Lambda]temp,YT}]];DD**)
\[Lambda]temp=(PadRight[Diagonal[\[Lambda]temp],\[Chi]]); (* Truncated values *)
norm2=Total[\[Lambda]temp^2];
TEBD[[centerSite1,2]]=SparseArray[\[Lambda]temp/Sqrt[norm2]];
(* The center tensor we obtain taking out \[Lambda]1 *) 
\[Lambda]1Di=SparseArray[PseudoInverse[Normal[\[Lambda]1D],Tolerance->TOLERANCE]];
(**O Print["Check 3-4"];DD**)
TEBD[[centerSite1,1]]=SparseArray[Chop[(\[Lambda]1Di.#&)/@(Partition[X,{\[Chi],\[Chi]}][[All,1]])]];
(* The right tensor needs the inverse right lambda to fit *)
(**O Print["Check 3-5"];DD**)
(**O Print["Check 3-5 B: site "<>ToString[rightSite]<>", "<>ToString[Dimensions[#]&/@{YT,(Partition[ConjugateTranspose[YT],{\[Chi],\[Chi]}][[1,All]]),Transpose[{PadRight[Conjugate[#],\[Chi]]}]&/@YT}]];DD**)
\[CapitalSigma]=Flatten[\[Lambda]2D.Transpose[Partition[Partition[ConjugateTranspose[YT],{\[Chi],\[Chi]}][[1,All]],spin],{2,3,1,4}],{{2,1},{3,4}}];
(* And get the SVD as a normal case *)
{X,\[Lambda]temp,YT}=SingularValueDecomposition[\[CapitalSigma]]; 
(**O Print[ToString[Dimensions[#]&/@{X,\[Lambda]temp,YT}]];DD**)
\[Lambda]temp=(PadRight[Diagonal[\[Lambda]temp],\[Chi]]); (* Truncated values *)
norm3=Total[\[Lambda]temp^2];
TEBD[[centerSite2,2]]=SparseArray[\[Lambda]temp/Sqrt[norm2]];
(* The center tensor we obtain taking out \[Lambda]1 *) 
\[Lambda]2Di=SparseArray[PseudoInverse[Normal[\[Lambda]2D],Tolerance->TOLERANCE]];
(**O Print["Check 3-4"];DD**)
TEBD[[centerSite2,1]]=SparseArray[Chop[(\[Lambda]2Di.#&)/@(Partition[X,{\[Chi],\[Chi]}][[All,1]])]];
(* The right tensor needs the inverse right lambda to fit *)
(**O Print["Check 3-5"];DD**)
(**O Print["Check 3-5 B: site "<>ToString[rightSite]<>", "<>ToString[Dimensions[#]&/@{YT,(Partition[ConjugateTranspose[YT],{\[Chi],\[Chi]}][[1,All]]),Transpose[{PadRight[Conjugate[#],\[Chi]]}]&/@YT}]];DD**)
\[Lambda]RDi=SparseArray[PseudoInverse[Normal[\[Lambda]RD],Tolerance->TOLERANCE]];
TEBD[[rightSite,1]]=SparseArray[Chop[(#.\[Lambda]RDi&)/@(Partition[ConjugateTranspose[YT],{\[Chi],\[Chi]}][[1,All]])]];
3-norm1-norm2-norm3]


SetAttributes[TEBD1QGate,HoldFirst]
TEBD1QGate[TEBD_,site_,H_]:=Module[{error,numSites,spin},
numSites=Length[TEBD];
If[(1<=site<=numSites)!=True,Print["TEBD1QGate called with wrong site."];Abort[]];
spin=Length[TEBD[[site,1]]];
If[Dimensions[H]!={spin,spin},Print["TEBD3QGate called with wrong operator dimensions."];Abort[]];
TEBD[[site,1]]=SparseArray[H.TEBD[[site,1]]];
0
]


SetAttributes[TEBDEvolve,HoldFirst];
TEBDEvolve[TEBD_,OperatorList_,steps_:1]:=Module[{error},
error=0;
Do[
Do[
error+=TEBDGate[TEBD,OperatorList[[n]]];
,{n,1,Length[OperatorList],1}];
Do[
error+=TEBDGate[TEBD,OperatorList[[n]]];
,{n,Length[OperatorList],1,-1}];
,{steps}];
error
]



SetAttributes[TEBDEvol3BodyPBC,HoldAll]
TEBDEvol3BodyPBC[TEBD_,H_,\[Tau]_]:=Module[{error,numSites,spin,U,Uedge},
numSites=Length[TEBD];
If[Dimensions[H]!={spin^3,spin^3},Print["TEBDEvol3BodyPBC called with wrong operator dimensions."];Abort[]];
U=MatrixExp[-I H \[Tau]/2];
Uedge=MatrixExp[-I H \[Tau]];
error=0;
(* First do the bulk evolutions *)
Do[(**OPrint["n"<>ToString[n]];DD**)error+=TEBD3QGate[TEBD,n,U];,{n,2,numSites-1,3}];
Do[(**OPrint["n"<>ToString[n]];DD**)error+=TEBD3QGate[TEBD,n,U];,{n,3,numSites-1,3}];
Do[(**OPrint["n"<>ToString[n]];DD**)error+=TEBD3QGate[TEBD,n,U];,{n,4,numSites-1,3}];
(* Now the edge interactions are made through swaps. Sites 1 and 2 are taken to the right end *)
Do[
error+=TEBD2QGate[TEBD,n+1,Swap];
error+=TEBD2QGate[TEBD,n,Swap];,
{n,1,numSites-2}];
error+=TEBD3QGate[TEBD,numSites-2,U];
(* Up to here is one evolution operator for half the time. Now do the central *)
error+=TEBD3QGate[TEBD,numSites-1,Uedge];
(* From here do the same transposed *)
error+=TEBD3QGate[TEBD,numSites-2,U];
(* Swap back into position *)
Do[
error+=TEBD2QGate[TEBD,n,Swap];
error+=TEBD2QGate[TEBD,n+1,Swap];,
{n,numSites-2,1,-1}];
(* Do the bulk again *) 
Do[error+=TEBD3QGate[TEBD,n,U];,{n,4,numSites-1,3}];
Do[error+=TEBD3QGate[TEBD,n,U];,{n,3,numSites-1,3}];
Do[error+=TEBD3QGate[TEBD,n,U];,{n,2,numSites-1,3}];
error
]


SetAttributes[TEBDEvol3BodyPBCDisorder,HoldAll]
TEBDEvol3BodyPBCDisorder[TEBD_,H_,\[Tau]_]:=Module[{error,numSites,spin},
numSites=Length[TEBD];
If[Dimensions[H]!={numSites,spin^3,spin^3},Print["TEBDEvol3BodyPBC called with wrong operator dimensions."];Abort[]];
error=0;
(* First do the bulk evolutions *)
Do[error+=TEBD3QGate[TEBD,n,MatrixExp[-I H [[n]]\[Tau]/2]];,{n,2,numSites-1,3}];
Do[error+=TEBD3QGate[TEBD,n,MatrixExp[-I H [[n]]\[Tau]/2]];,{n,3,numSites-1,3}];
Do[error+=TEBD3QGate[TEBD,n,MatrixExp[-I H [[n]]\[Tau]/2]];,{n,4,numSites-1,3}];
(* Now the edge interactions are made through swaps. Sites 1 and 2 are taken to the right end *)
Do[
error+=TEBD2QGate[TEBD,n+1,Swap];
error+=TEBD2QGate[TEBD,n,Swap];,
{n,1,numSites-2}];
error+=TEBD3QGate[TEBD,numSites-2,MatrixExp[-I H [[numSites-2]]\[Tau]/2]];
(* Up to here is one evolution operator for half the time. Now do the central *)
error+=TEBD3QGate[TEBD,numSites-1,MatrixExp[-I H [[numSites-1]]\[Tau]]];
(* From here do the same transposed *)
error+=TEBD3QGate[TEBD,numSites-2,MatrixExp[-I H [[numSites-2]]\[Tau]/2]];
(* Swap back into position *)
Do[
error+=TEBD2QGate[TEBD,n,Swap];
error+=TEBD2QGate[TEBD,n+1,Swap];,
{n,numSites-2,1,-1}];
(* Do the bulk again *) 
Do[error+=TEBD3QGate[TEBD,n,MatrixExp[-I H [[n]]\[Tau]/2]];,{n,4,numSites-1,3}];
Do[error+=TEBD3QGate[TEBD,n,MatrixExp[-I H [[n]]\[Tau]/2]];,{n,3,numSites-1,3}];
Do[error+=TEBD3QGate[TEBD,n,MatrixExp[-I H [[n]]\[Tau]/2]];,{n,2,numSites-1,3}];
error
]


SetAttributes[TEBDEvol3BodyOBC,HoldAll]
TEBDEvol3BodyOBC[TEBD_,H_,\[Tau]_]:=Module[{error,numSites,spin,U,Uedge},
numSites=Length[TEBD];
If[Dimensions[H]!={spin^3,spin^3},Print["TEBDEvol3BodyPBC called with wrong operator dimensions."];Abort[]];
U=MatrixExp[-I H \[Tau]/2];
Uedge=MatrixExp[-I H \[Tau]];
error=0;
(* First do the bulk evolutions *)
Do[(**OPrint["n"<>ToString[n]];DD**)error+=TEBD3QGate[TEBD,n,U];,{n,2,numSites-1,3}];
Do[(**OPrint["n"<>ToString[n]];DD**)error+=TEBD3QGate[TEBD,n,U];,{n,3,numSites-1,3}];
Do[(**OPrint["n"<>ToString[n]];DD**)error+=TEBD3QGate[TEBD,n,Uedge];,{n,4,numSites-1,3}];
Do[error+=TEBD3QGate[TEBD,n,U];,{n,3,numSites-1,3}];
Do[error+=TEBD3QGate[TEBD,n,U];,{n,2,numSites-1,3}];
error
]


SetAttributes[TEBDEvol3BodyOBCDisorder,HoldAll]
TEBDEvol3BodyOBCDisorder[TEBD_,H_,\[Tau]_]:=Module[{error,numSites,spin},
numSites=Length[TEBD];
If[Dimensions[H]!={numSites,spin^3,spin^3},Print["TEBDEvol3BodyPBC called with wrong operator dimensions."];Abort[]];
error=0;
(* First do the bulk evolutions *)
Do[error+=TEBD3QGate[TEBD,n,MatrixExp[-I H [[n]]\[Tau]/2]];,{n,2,numSites-1,3}];
Do[error+=TEBD3QGate[TEBD,n,MatrixExp[-I H [[n]]\[Tau]/2]];,{n,3,numSites-1,3}];
Do[error+=TEBD3QGate[TEBD,n,MatrixExp[-I H [[n]]\[Tau]]];,{n,4,numSites-1,3}];
Do[error+=TEBD3QGate[TEBD,n,MatrixExp[-I H [[n]]\[Tau]/2]];,{n,3,numSites-1,3}];
Do[error+=TEBD3QGate[TEBD,n,MatrixExp[-I H [[n]]\[Tau]/2]];,{n,2,numSites-1,3}];
error
]


SetAttributes[TEBDEvol2BodyPBC,HoldAll]
TEBDEvol2BodyPBC[TEBD_,H_,\[Tau]_]:=Module[{error,numSites,spin,U,Uedge},
numSites=Length[TEBD];
If[Dimensions[H]!={spin^2,spin^2},Print["TEBDEvol2BodyPBC called with wrong operator dimensions."];Abort[]];
U=MatrixExp[-I H \[Tau]/2];
Uedge=MatrixExp[-I H \[Tau]];
error=0;
(* First do the bulk evolutions *)
Do[(**OPrint["n"<>ToString[n]];DD**)error+=TEBD2QGate[TEBD,n,U];,{n,1,numSites-1,2}];
Do[(**OPrint["n"<>ToString[n]];DD**)error+=TEBD2QGate[TEBD,n,U];,{n,2,numSites-1,2}];
(* Now the edge interactions are made through swaps.  *)
Do[
error+=TEBD2QGate[TEBD,n,Swap];,
{n,1,numSites-1}];
(* Up to here is one evolution operator for half the time. Now do the central *)
error+=TEBD2QGate[TEBD,numSites-1,Uedge];
(* From here do the same transposed *)
(* Swap back into position *)
Do[
error+=TEBD2QGate[TEBD,n,Swap];
,{n,numSites-1,1,-1}];
(* Do the bulk again *) 
Do[error+=TEBD2QGate[TEBD,n,U];,{n,2,numSites-1,2}];
Do[error+=TEBD2QGate[TEBD,n,U];,{n,1,numSites-1,2}];
error
]


SetAttributes[TEBDEvol2BodyOBC,HoldAll]
TEBDEvol2BodyOBC[TEBD_,H_,\[Tau]_]:=Module[{error,numSites,spin,U,Uedge},
numSites=Length[TEBD];
If[Dimensions[H]!={spin^2,spin^2},Print["TEBDEvol3BodyPBC called with wrong operator dimensions."];Abort[]];
U=MatrixExp[-I H \[Tau]/2];
Uedge=MatrixExp[-I H \[Tau]];
error=0;
(* First do the bulk evolutions *)
Do[(**OPrint["n"<>ToString[n]];DD**)
error+=TEBD2QGate[TEBD,n,U],{n,1,numSites-1,2}];
Do[(**OPrint["n"<>ToString[n]];DD**)error+=TEBD2QGate[TEBD,n,Uedge],{n,2,numSites-1,2}];
Do[error+=TEBD2QGate[TEBD,n,U],{n,1,numSites-1,2}];
error
]


SetAttributes[TEBDExpectation1O,HoldFirst];
TEBDExpectation1O[TEBD_,site_,Operator_]:=Module[{Mdown,Mup,value,numSites,\[Lambda]L,\[Lambda]R,spin},
value=0;
numSites=Length[TEBD];
If[(1<=site<=numSites)!=True,Print["TEBDExpectation1O called with wrong site parameter."];Abort[]];
spin=Length[TEBD[[site,1]]];
If[Dimensions[Operator]!={spin,spin},Print["TEBDExpectation1O called with wrong operator dimensions."];Abort[]];
If[site==1,
\[Lambda]L=SparseArray[DiagonalMatrix[TEBD[[numSites,2]]]];,
\[Lambda]L=SparseArray[DiagonalMatrix[TEBD[[site-1,2]]]];
];
\[Lambda]R=SparseArray[DiagonalMatrix[TEBD[[site,2]]]];
Mup=Flatten[\[Lambda]L.Transpose[(Operator.TEBD[[site,1]]),{2,1,3}].\[Lambda]R];
Mdown=Flatten[\[Lambda]L.Transpose[Conjugate[TEBD[[site,1]]],{2,1,3}].\[Lambda]R];
Chop[Mdown.Mup]
]


SetAttributes[TEBDExpectation2OList,HoldFirst];
SetAttributes[TEBDExpectation2O,HoldAll];
TEBDExpectation2O[TEBD_,siteL_,siteR_,OperatorL_,OperatorR_]:=Last[TEBDExpectation2OList[TEBD,siteL,siteR,OperatorL,OperatorR]][[2]]
TEBDExpectation2OList[TEBD_,site1_,site2_,OperatorL_,OperatorR_]:=Module[{numSites,M,temp,spin,\[Lambda]L,siteL,siteR},
numSites=Length[TEBD];
{siteL,siteR}=Sort[{site1,site2}];
If[(1<=siteL<siteR<=numSites)!=True,Print["TEBDExpectation2OList called with wrong site parameter."];Abort[]];
spin=Length[TEBD[[siteL,1]]];
If[Dimensions[OperatorL]!={spin,spin}||Dimensions[OperatorR]!={spin,spin},Print["TEBDExpectation1O called with wrong operator dimensions."];Abort[]];
If[siteL==1,
\[Lambda]L=SparseArray[DiagonalMatrix[TEBD[[numSites,2]]]];,
\[Lambda]L=SparseArray[DiagonalMatrix[TEBD[[siteL-1,2]]]];
];
(* This will do a loop over the different tensors in the TEBD *)

(* First prepare the initial matrix with the action of the Operator1 on the starting tensor *)
M=SparseArray[DiagonalMatrix[TEBD[[siteL,2]]]].Sum[ConjugateTranspose[TEBD[[siteL,1,i]]].(\[Lambda]L^2).((OperatorL.TEBD[[siteL,1]])[[i]]),{i,1,spin}].SparseArray[DiagonalMatrix[TEBD[[siteL,2]]]];
(* The expectation value is added a table as a function of distance *)
Table[{dist,
(* First we calculate the expectation value using Operator2 *)
temp=Tr[SparseArray[DiagonalMatrix[TEBD[[siteL+dist,2]]]].Sum[ConjugateTranspose[TEBD[[siteL+dist,1,i]]].M.((OperatorR.TEBD[[siteL+dist,1]])[[i]]),{i,1,spin}].SparseArray[DiagonalMatrix[TEBD[[siteL+dist,2]]]]];
(* Now almost the same computation but for the following iteration, without the Operator2. The last computation is useless... *)
M=SparseArray[DiagonalMatrix[TEBD[[siteL+dist,2]]]].Sum[ConjugateTranspose[TEBD[[siteL+dist,1,i]]].M.TEBD[[siteL+dist,1,i]],{i,1,spin}].SparseArray[DiagonalMatrix[TEBD[[siteL+dist,2]]]];
Chop[temp]
},{dist,1,siteR-siteL}]
]


SetAttributes[TEBDExpectation3O,HoldAll];
TEBDExpectation3O[TEBD_,site1_,site2_,site3_,OperatorL_,OperatorC_,OperatorR_]:=Module[{numSites,M,temp,spin,\[Lambda]L,siteL,siteC,siteR},
numSites=Length[TEBD];
{siteL,siteC,siteR}=Sort[{site1,site2,site3}];
If[(1<=siteL<siteC<siteR<=numSites)!=True,Print["TEBDExpectation3O called with wrong site parameter."];Abort[]];
spin=Length[TEBD[[siteL,1]]];
If[Dimensions[OperatorL]!={spin,spin}||Dimensions[OperatorC]!={spin,spin}||Dimensions[OperatorR]!={spin,spin},Print["TEBDExpectation1O called with wrong operator dimensions."];Abort[]];
If[siteL==1,
\[Lambda]L=SparseArray[DiagonalMatrix[TEBD[[numSites,2]]]];,
\[Lambda]L=SparseArray[DiagonalMatrix[TEBD[[siteL-1,2]]]];
];
(* First prepare the initial matrix with the action of the OperatorL on the starting tensor *)
M=SparseArray[DiagonalMatrix[TEBD[[siteL,2]]]].Sum[ConjugateTranspose[TEBD[[siteL,1,i]]].(\[Lambda]L^2).((OperatorL.TEBD[[siteL,1]])[[i]]),{i,1,spin}].SparseArray[DiagonalMatrix[TEBD[[siteL,2]]]];
(* Now eat tensors away until the center site siteC *)
Do[M=SparseArray[DiagonalMatrix[TEBD[[siteL+dist,2]]]].Sum[ConjugateTranspose[TEBD[[siteL+dist,1,i]]].M.TEBD[[siteL+dist,1,i]],{i,1,spin}].SparseArray[DiagonalMatrix[TEBD[[siteL+dist,2]]]];,{dist,1,siteC-1-siteL}];
(* Now eat the center tensor *)
M=SparseArray[DiagonalMatrix[TEBD[[siteC,2]]]].Sum[ConjugateTranspose[TEBD[[siteC,1,i]]].M.((OperatorR.TEBD[[siteC,1]])[[i]]),{i,1,spin}].SparseArray[DiagonalMatrix[TEBD[[siteC,2]]]];
(* And keep on going until we reach the last tensor *)
Do[M=SparseArray[DiagonalMatrix[TEBD[[siteC+dist,2]]]].Sum[ConjugateTranspose[TEBD[[siteC+dist,1,i]]].M.TEBD[[siteC+dist,1,i]],{i,1,spin}].SparseArray[DiagonalMatrix[TEBD[[siteC+dist,2]]]];,{dist,1,siteR-1-siteC}];
(* Return expectation value *)
Chop[Tr[SparseArray[DiagonalMatrix[TEBD[[siteR,2]]]].Sum[ConjugateTranspose[TEBD[[siteR,1,i]]].M.((OperatorR.TEBD[[siteR,1]])[[i]]),{i,1,spin}].SparseArray[DiagonalMatrix[TEBD[[siteR,2]]]]]]
]

TEBDExpectation3O[TEBD_,site_,Operator_]:=Module[{numSites,M,temp,spin,\[Lambda]L},
numSites=Length[TEBD];
If[(1<site<numSites)!=True,Print["TEBDExpectation3O (B) called with wrong site parameter."];Abort[]];
spin=Length[TEBD[[site,1]]];
If[Dimensions[Operator]!={spin^3,spin^3},Print["TEBDExpectation1O(B) called with wrong operator dimensions."];Abort[]];
If[site==2,
\[Lambda]L=SparseArray[DiagonalMatrix[TEBD[[numSites,2]]]];,
\[Lambda]L=SparseArray[DiagonalMatrix[TEBD[[site-2,2]]]];
];
(* First prepare the initial matrix with the action of the OperatorL on the starting tensor *)
M=SparseArray[DiagonalMatrix[TEBD[[site+1,2]]]].Sum[ConjugateTranspose[Flatten[TEBD[[site-1,1]].SparseArray[DiagonalMatrix[TEBD[[site-1,2]]]].Transpose[TEBD[[site,1]],{2,1,3}].SparseArray[DiagonalMatrix[TEBD[[site,2]]]].Transpose[TEBD[[site+1,1]],{2,1,3}],{{1,3,4},{2},{5}}][[i]]].(\[Lambda]L^2).(Operator.Flatten[TEBD[[site-1,1]].SparseArray[DiagonalMatrix[TEBD[[site-1,2]]]].Transpose[TEBD[[site,1]],{2,1,3}].SparseArray[DiagonalMatrix[TEBD[[site,2]]]].Transpose[TEBD[[site+1,1]],{2,1,3}],{{1,3,4},{2},{5}}]
)[[i]],{i,1,spin^3}].SparseArray[DiagonalMatrix[TEBD[[site+1,2]]]];
Chop[Tr[M]]
]


TEBDentropy[\[Lambda]_]:=-Sum[If[\[Lambda][[n]]>0,\[Lambda][[n]]^2Log[2,\[Lambda][[n]]^2],0],{n,1,Length[\[Lambda]]}];
TEBDentropyList[TEBD_]:=Table[{n,TEBDentropy[TEBD[[n,2]]]},{n,1,Length[TEBD]-1}]


SetAttributes[TEBDInitHamiltonian,HoldFirst];
TEBDInitHamiltonian[Ham_]:=(Ham={})


SetAttributes[TEBDHamiltonianAdd,HoldFirst];
TEBDHamiltonianAdd[Ham_,operator_,site1_,site2_]:=(Ham=(Ham~Join~{{operator,site1,site2}}))


TEBDHamiltonianAdd[Ham_,operator_,site_]:=(Ham=(Ham~Join~{{operator,site,site}}))


TEBDEvolutionOperator[Ham_,time_]:=Table[{MatrixExp[-I time Ham[[n,1]]],Ham[[n,2]],Ham[[n,3]]},{n,1,Length[Ham]}]



