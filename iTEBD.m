(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



iTEBDSpin=2;
iTEBDBond=20;
iTEBDMaxBond=100;
iTEBDTolerance=10^(-15);
iTEBDMaxIterations=20;



Clear[iTEBDProductState];
Options[iTEBDProductState]={Spin->iTEBDSpin,Bond->iTEBDBond,Type->{"Random",{}}};
iTEBDProductState[numTensors_,OptionsPattern[]]:=Module[{\[CapitalGamma]=Array[0&,{numTensors}],\[Lambda]=Array[0&,{numTensors}],tempType=OptionValue[Type],type,coeffList,spin=OptionValue[Spin],\[Chi]=OptionValue[Bond]},
{type,coeffList}=tempType;
Switch[type,
"Specified",If[Dimensions[coeffList]!={numTensors,spin},Print["TEBDProductState called with wrong list of phases."];Abort[]],
"Identity",coeffList=Table[{0.0,1.0}~Join~Table[0.0,{m,1,spin-2}],{k,1,numTensors}],
"Decaying",coeffList=Table[Normalize[Table[Exp[-0.5 Log[20](m-1)/spin],{m,1,spin}]],{k,1,numTensors}];,
"Random",coeffList=Table[Normalize[RandomComplex[{-1-I,1+I},spin]],{k,1,numTensors}];
];
Table[{
Table[SparseArray[{{i_,j_}/;(i==j==1)->coeffList[[k,n]]},{\[Chi],\[Chi]}],{n,1,spin}],
SparseArray[{i_}/;i<=1->1.0 ,{\[Chi]}]},
{k,1,numTensors}]
];


iTEBDExpandBond[TEBD_,new\[Chi]_]:=Module[
{},
Print["Grow \[Chi] to "<>ToString[new\[Chi]]];
Table[{PadRight[#,{new\[Chi],new\[Chi]}]&/@TEBD[[M,1]],PadRight[TEBD[[M,2]],new\[Chi]]},{M,1,Length[TEBD]}]
];


SetAttributes[iTEBDSave,HoldFirst];
iTEBDSave[iTEBD_,filename_]:=Module[{numSites,spin,\[Chi]},
numSites=Length[iTEBD];
spin=Length[iTEBD[[1,1]]];
\[Chi]=Length[iTEBD[[1,1,1]]];
Export[filename<>".info",{numSites,spin,\[Chi]},"Table"];
Do[
Do[
Export[filename<>".G."<>ToString[n]<>"."<>ToString[s]<>".dat",iTEBD[[n,1,s]],"Table"]
,{s,1,spin}];
Export[filename<>".L."<>ToString[n]<>".dat",iTEBD[[n,2]],"Table"];
,{n,1,numSites}]
];


iTEBDRead[filename_]:=Module[{iTEBD,numSites,spin,\[Chi],info},
info=Flatten[Import[filename<>".info","Table"]];
{numSites,spin,\[Chi]}=info;
iTEBD=iTEBDProductState[numSites,Spin->spin,Bond->\[Chi]];
Do[
iTEBD[[n,1]]=SparseArray[Table[
Import[filename<>".G."<>ToString[n]<>"."<>ToString[s]<>".dat","Table"]
,{s,1,spin}]];
iTEBD[[n,2]]=SparseArray[Flatten[Import[filename<>".L."<>ToString[n]<>".dat","Table"]]];
,{n,1,numSites}];
iTEBD
];


SetAttributes[iTEBD2QGate,HoldFirst];
iTEBD2QGate[iTEBD_,H_]:=Module[{spin,\[Chi],Hint,\[Lambda]LD,\[Lambda]CD,\[Lambda]RD,\[CapitalSigma],X,YT,\[Lambda]temp,\[Lambda]RDi,\[Lambda]LDi,norm,numTensors},
(*   Print[step=0.1,\[Lambda]L,\[Lambda]C,\[Lambda]R]; Preliminary: prepare matrices for fast products *)
numTensors=Length[iTEBD];
spin=Length[iTEBD[[1,1]]];
\[Chi]=Length[iTEBD[[1,1,1]]];
Hint=((Partition[#,spin]&/@H));
\[Lambda]LD=SparseArray[DiagonalMatrix[iTEBD[[2,2]]]];
\[Lambda]CD=SparseArray[DiagonalMatrix[iTEBD[[1,2]]]];
\[Lambda]RD=SparseArray[DiagonalMatrix[iTEBD[[2,2]]]];
(* Print[step=1.5,Dimensions[#]&/@{\[Lambda]LD,\[Lambda]CD,\[Lambda]RD}];  Steps (i) and (iii): compute theta tensors *)
\[CapitalSigma]=Flatten[Flatten[\[Lambda]LD.Transpose[iTEBD[[1,1]],{2,1,3}].\[Lambda]CD.Transpose[iTEBD[[2,1]],{2,1,3}].\[Lambda]RD,{{1},{4},{2,3}}].Hint,{{3,1},{4,2}}];
(*  Print[step=8];Step (viii): Compute SVD of \[CapitalSigma] *)
{X,\[Lambda]temp,YT}=SingularValueDecomposition[\[CapitalSigma]]; 
\[Lambda]CD=(Diagonal[\[Lambda]temp])[[1;;\[Chi]]]; (* Truncated values *)
norm=Total[\[Lambda]CD^2];
iTEBD[[1,2]]=\[Lambda]CD/Sqrt[norm];
(* Print[step=9]; Step (ix): Reformat P and Q to the new Gammas and truncate to \[Chi] *)
\[Lambda]LDi=SparseArray[PseudoInverse[Normal[\[Lambda]LD]]];
\[Lambda]RDi=SparseArray[PseudoInverse[Normal[\[Lambda]RD]]];
iTEBD[[1,1]]=SparseArray[Chop[(\[Lambda]LDi.#&)/@(Partition[X,{\[Chi],\[Chi]}][[All,1]])]];
iTEBD[[2,1]]=SparseArray[Chop[(#.\[Lambda]RDi&)/@(Partition[ConjugateTranspose[YT],{\[Chi],\[Chi]}][[1,All]])]];
1-norm
];


SetAttributes[iTEBDMPO,HoldAll];
iTEBDMPO[iTEBD_,iMPO_]:=Module[{temp,\[Chi]D},
\[Chi]D=Last[Dimensions[iMPO]];
MapThread[{Flatten[Transpose[#1[[1]],{3,1,2}].#2,{{3},{1,4},{2,5}}],Flatten[KroneckerProduct[#1[[2]],Array[1.&,{\[Chi]D}]]]}&,{iTEBD,iMPO}]
];


ClearAttributes[iTEBDApplyTheta,HoldAll];
iTEBDApplyTheta[A_,v_]:=Module[{r,temp},
temp=Sum[A[[i]].v.ConjugateTranspose[A[[i]]],{i,1,Length[A]}];
temp/Sqrt[Total[Flatten[Abs[temp]^2]]]];


SetAttributes[iTEBDWithMPO,HoldFirst];
Options[iTEBDWithMPO]={Verbose->False};
iTEBDWithMPO[iTEBD_,iMPO_,OptionsPattern[]]:=Module[{\[Chi],\[Chi]D,\[Lambda]LD,\[Lambda]CD,\[Lambda]RD,\[CapitalSigma],X,YT,v,W,Xi,YTi,U,VD,V,\[Lambda]temp,\[Lambda]RDi,\[Lambda]LDi,\[Theta],VR,VL,norm,numTensors,mps,error,verbose=OptionValue[Verbose],tempcell},
(*   Print[step=0.1,\[Lambda]L,\[Lambda]C,\[Lambda]R]; Preliminary: prepare matrices for fast products *)
If[verbose,tempcell=Print["Preparing matrices"]];
numTensors=Length[iTEBD];
\[Chi]=Length[iTEBD[[1,1,1]]];
\[Chi]D=Last[Dimensions[iMPO]];
(* Create a larger iTEBD including the iMPO *)
mps=iTEBDMPO[iTEBD,iMPO];
\[Lambda]LD=DiagonalMatrix[mps[[2,2]]];
\[Lambda]CD=DiagonalMatrix[mps[[1,2]]];
\[Lambda]RD=DiagonalMatrix[mps[[2,2]]];
(* Construct \[Theta] matrix leaving spin indices in the middle \[Alpha],i,j,\[Beta] *)
\[Theta]=Transpose[mps[[1,1]],{2,1,3}].\[Lambda]CD.Transpose[mps[[2,1]],{2,1,3}];
(* Find left and right eigenvectors of \[Theta] *)
If[verbose,NotebookDelete[tempcell];tempcell=Print["Computing right maximum eigv"<>ToString[Dimensions[Flatten[\[Theta].\[Lambda]RD,{{2,3},{1},{4}}]]]]];
VR=iTEBDMaxEigenvector[Flatten[\[Theta].\[Lambda]RD,{{2,3},{1},{4}}],Verbose->verbose];
If[verbose,NotebookDelete[tempcell];tempcell=Print["Computing left maximum eigv"]];VL=iTEBDMaxEigenvector[Flatten[\[Lambda]LD.\[Theta],{{2,3},{1},{4}}],Verbose->verbose];
(* Now find decomposition of VR and VL in positive matrices *)
If[verbose,NotebookDelete[tempcell];tempcell=Print["Decomposing right and left tensors"]];
{v,W}=Eigensystem[VR]; (*   VR=XX^\[Dagger] Notice that VR=WT.D.W^* in Mathematica *)
X=Transpose[W].DiagonalMatrix[Sqrt[v]];
{v,W}=Eigensystem[VL]; (* VL=Y^\[Dagger] Y *)
YT=Transpose[DiagonalMatrix[Sqrt[v]].Conjugate[W]];
(* Print[step=6]; Step (vi): Compute SVD of YT.\[Lambda]R.X *)
If[verbose,NotebookDelete[tempcell];tempcell=Print["Computing first SVD"]];
Xi=PseudoInverse[Normal[Chop[X]]];
YTi=PseudoInverse[Normal[Chop[YT]]];
{U,\[Lambda]RDi,VD}=SingularValueDecomposition[YT.\[Lambda]RD.X];
V=ConjugateTranspose[VD];
(* Extract and normalize the new \[Lambda] *)
\[Lambda]RDi=Diagonal[\[Lambda]RDi][[1;;\[Chi]]];
norm=Sqrt[Total[\[Lambda]RDi^2]];
error=1-norm;
iTEBD[[2,2]]=\[Lambda]RDi/norm;
\[Lambda]RD=SparseArray[DiagonalMatrix[iTEBD[[2,2]]]];
\[Lambda]LD=\[Lambda]RD;
If[verbose,NotebookDelete[tempcell];tempcell=Print["Prepare new SVD"]];
(* Prepare and truncate auxiliary matrices to make \[CapitalSigma] simpler *)
X=(V.Xi)[[1;;\[Chi],All]];
YT=(YTi.U)[[All,1;;\[Chi]]];
(* Construct the \[CapitalSigma] matrix for final decomposition with indices (i\[Alpha]),(j\[Beta]) *)
\[CapitalSigma]=Flatten[\[Lambda]LD.X.\[Theta].YT.\[Lambda]RD,{{2,1},{3,4}}];
(*  Print[step=8];Step (viii): Compute SVD of \[CapitalSigma] *)
{X,\[Lambda]temp,YT}=SingularValueDecomposition[\[CapitalSigma]]; 
If[verbose,NotebookDelete[tempcell];tempcell=Print["Finalize new assignments"]];
\[Lambda]CD=(Diagonal[\[Lambda]temp])[[1;;\[Chi]]]; (* Truncated values *)
norm=Total[\[Lambda]CD^2];
error+=1-norm;
iTEBD[[1,2]]=\[Lambda]CD/Sqrt[norm];
(* Print[step=9]; Step (ix): Reformat X and YT to the new Gammas and truncate to \[Chi] *)
\[Lambda]LDi=SparseArray[PseudoInverse[Normal[\[Lambda]LD]]];
\[Lambda]RDi=SparseArray[PseudoInverse[Normal[\[Lambda]RD]]];
iTEBD[[1,1]]=SparseArray[Chop[(\[Lambda]LDi.#&)/@(Partition[X,{\[Chi],\[Chi]}][[All,1]])]];
iTEBD[[2,1]]=SparseArray[Chop[(#.\[Lambda]RDi&)/@(Partition[ConjugateTranspose[YT],{\[Chi],\[Chi]}][[1,All]])]];
If[verbose,NotebookDelete[tempcell];];
error
]


SetAttributes[iTEBDNUGate,HoldFirst];
iTEBDNuGate[iTEBD_,H_]:=Module[{\[Chi],\[Lambda]LD,Hint,\[Lambda]CD,\[Lambda]RD,\[CapitalSigma],X,YT,v,W,Xi,YTi,U,VD,V,\[Lambda]temp,\[Lambda]RDi,\[Lambda]LDi,\[Theta],VR,VL,norm,numTensors,mps,error},
(*   Print[step=0.1,\[Lambda]L,\[Lambda]C,\[Lambda]R]; Preliminary: prepare matrices for fast products *)
numTensors=Length[iTEBD];
Hint=((Partition[#,2]&/@H));
\[Chi]=Length[iTEBD[[1,1,1]]];
(* Create a larger iTEBD including the iMPO *)
\[Lambda]LD=DiagonalMatrix[iTEBD[[2,2]]];
\[Lambda]CD=DiagonalMatrix[iTEBD[[1,2]]];
\[Lambda]RD=DiagonalMatrix[iTEBD[[2,2]]];
(* Construct \[Theta] matrix leaving spin indices in the middle \[Alpha],i,j,\[Beta] *)
\[Theta]=Flatten[Flatten[Transpose[iTEBD[[1,1]],{2,1,3}].\[Lambda]CD.Transpose[iTEBD[[2,1]],{2,1,3}],{{1},{4},{2,3}}].Hint,{{1},{3},{4},{2}}];
(* Find left and right eigenvectors of \[Theta] *)
VR=iTEBDMaxEigenvector[Flatten[\[Theta].\[Lambda]RD,{{2,3},{1},{4}}]];
VL=iTEBDMaxEigenvector[Flatten[\[Lambda]LD.\[Theta],{{2,3},{1},{4}}]];
(* Now find decomposition of VR and VL in positive matrices *)
{v,W}=Eigensystem[VR]; (*   VR=XX^\[Dagger] Notice that VR=WT.D.W^* in Mathematica *)
X=Transpose[W].DiagonalMatrix[Sqrt[v]];
{v,W}=Eigensystem[VL]; (* VL=Y^\[Dagger] Y *)
YT=Transpose[DiagonalMatrix[Sqrt[v]].Conjugate[W]];
(* Print[step=6]; Step (vi): Compute SVD of YT.\[Lambda]R.X *)
Xi=PseudoInverse[Normal[Chop[X]]];
YTi=PseudoInverse[Normal[Chop[YT]]];
{U,\[Lambda]RDi,VD}=SingularValueDecomposition[YT.\[Lambda]RD.X];
V=ConjugateTranspose[VD];
(* Extract and normalize the new \[Lambda] *)
\[Lambda]RDi=Diagonal[\[Lambda]RDi][[1;;\[Chi]]];
norm=Sqrt[Total[\[Lambda]RDi^2]];
error=1-norm;
iTEBD[[2,2]]=\[Lambda]RDi/norm;
\[Lambda]RD=SparseArray[DiagonalMatrix[iTEBD[[2,2]]]];
\[Lambda]LD=\[Lambda]RD;
(* Prepare and truncate auxiliary matrices to make \[CapitalSigma] simpler *)
X=(V.Xi)[[1;;\[Chi],All]];
YT=(YTi.U)[[All,1;;\[Chi]]];
(* Construct the \[CapitalSigma] matrix for final decomposition with indices (i\[Alpha]),(j\[Beta]) *)
\[CapitalSigma]=Flatten[\[Lambda]LD.X.\[Theta].YT.\[Lambda]RD,{{2,1},{3,4}}];
(*  Print[step=8];Step (viii): Compute SVD of \[CapitalSigma] *)
{X,\[Lambda]temp,YT}=SingularValueDecomposition[\[CapitalSigma]]; 
\[Lambda]CD=(Diagonal[\[Lambda]temp])[[1;;\[Chi]]]; (* Truncated values *)
norm=Total[\[Lambda]CD^2];
error+=1-norm;
iTEBD[[1,2]]=\[Lambda]CD/Sqrt[norm];
(* Print[step=9]; Step (ix): Reformat X and YT to the new Gammas and truncate to \[Chi] *)
\[Lambda]LDi=SparseArray[PseudoInverse[Normal[\[Lambda]LD]]];
\[Lambda]RDi=SparseArray[PseudoInverse[Normal[\[Lambda]RD]]];
iTEBD[[1,1]]=SparseArray[Chop[(\[Lambda]LDi.#&)/@(Partition[X,{\[Chi],\[Chi]}][[All,1]])]];
iTEBD[[2,1]]=SparseArray[Chop[(#.\[Lambda]RDi&)/@(Partition[ConjugateTranspose[YT],{\[Chi],\[Chi]}][[1,All]])]];
error
]


SetAttributes[iTEBD3QGate,HoldFirst];
iTEBD3QGate[iTEBD_,H_]:=Module[{spin,\[Chi],\[Lambda]LD,\[Lambda]1D,\[Lambda]2D,\[Lambda]RD,\[CapitalSigma],X,YT,\[Lambda]temp,\[Lambda]RDi,\[Lambda]LDi,\[Lambda]1Di,norm1,norm2,numTensors,Hint},
 (*  Print[step=0];  Preliminary: prepare matrices for fast products *)
numTensors=Length[iTEBD];
{spin,\[Chi]}=Dimensions[iTEBD[[1,1]]][[1;;2]];
Hint=(Partition[#,spin]&/@(Partition[#,spin]&/@H));
\[Lambda]LD=SparseArray[DiagonalMatrix[iTEBD[[3,2]]]];
\[Lambda]1D=SparseArray[DiagonalMatrix[iTEBD[[1,2]]]];
\[Lambda]2D=SparseArray[DiagonalMatrix[iTEBD[[2,2]]]];
\[Lambda]RD=SparseArray[DiagonalMatrix[iTEBD[[3,2]]]];
(* First make 3 spin matrix  *)
\[CapitalSigma]=Flatten[Flatten[\[Lambda]LD.Transpose[iTEBD[[1,1]],{2,1,3}].\[Lambda]1D.Transpose[iTEBD[[2,1]],{2,1,3}].\[Lambda]2D.Transpose[iTEBD[[3,1]],{2,1,3}].\[Lambda]RD,{{1},{5},{2,3,4}}].Hint,{{3,1},{4,5,2}}];
(*  Perform SVD of the three spin matrix as 1-2 spins *)
{X,\[Lambda]temp,YT}=SingularValueDecomposition[\[CapitalSigma]]; 
\[Lambda]temp=(Diagonal[\[Lambda]temp])[[1;;\[Chi]]]; (* Truncated values *)
norm1=Total[\[Lambda]temp^2];
iTEBD[[1,2]]=SparseArray[\[Lambda]temp/Sqrt[norm1]];
\[Lambda]1D=DiagonalMatrix[iTEBD[[1,2]]];
(* Extract the tensors of the left spin *)
\[Lambda]LDi=SparseArray[PseudoInverse[Normal[\[Lambda]LD]]];
iTEBD[[1,1]]=SparseArray[Chop[(\[Lambda]LDi.#&)/@(Partition[X,{\[Chi],\[Chi]}][[All,1]])]];
(* Now rearrange right matrix to represent 2 spins as 1-1, multiplying before by the new \[Lambda]1 *)
\[CapitalSigma]=Flatten[\[Lambda]1D.Transpose[Partition[Partition[ConjugateTranspose[YT],{\[Chi],\[Chi]}][[1,All]],spin],{2,3,1,4}],{{2,1},{3,4}}];
(* And get the SVD as a normal case *)
{X,\[Lambda]temp,YT}=SingularValueDecomposition[\[CapitalSigma]]; 
\[Lambda]temp=(Diagonal[\[Lambda]temp])[[1;;\[Chi]]]; (* Truncated values *)
norm2=Total[\[Lambda]temp^2];
iTEBD[[2,2]]=SparseArray[\[Lambda]temp/Sqrt[norm2]];
(* The center tensor we obtain taking out \[Lambda]1 *) 
\[Lambda]1Di=SparseArray[PseudoInverse[Normal[\[Lambda]1D]]];
iTEBD[[2,1]]=SparseArray[Chop[(\[Lambda]1Di.#&)/@(Partition[X,{\[Chi],\[Chi]}][[All,1]])]];
(* The right tensor needs the inverse right lambda to fit *)
\[Lambda]RDi=SparseArray[PseudoInverse[Normal[\[Lambda]RD]]];
iTEBD[[3,1]]=SparseArray[Chop[(#.\[Lambda]RDi&)/@(Partition[ConjugateTranspose[YT],{\[Chi],\[Chi]}][[1,All]])]];
2-norm1-norm2
]


SetAttributes[iTEBD3QMPO,HoldFirst];
iTEBD3QMPO[iTEBD_,iMPO_]:=Module[{spin,\[Chi],\[Lambda]LD,\[Lambda]1D,\[Lambda]2D,\[Lambda]RD,\[CapitalSigma],X,YT,\[Lambda]temp,\[Lambda]RDi,\[Lambda]LDi,\[Lambda]1Di,norm1,norm2,numTensors,Hint},
numTensors=Length[iTEBD];
{spin,\[Chi]}=Dimensions[iTEBD[[1,1]]][[1;;2]];
\[Chi]D=Last[Dimensions[iMPO]];
(* Create a larger iTEBD including the iMPO *)
mps=Table[MPOTEBD[iTEBD[[n]],iMPO[[n]]],{n,1,numTensors}];
\[Lambda]LD=SparseArray[PadRight[DiagonalMatrix[iTEBD[[2,2]]],{\[Chi] \[Chi]D}]];
\[Lambda]CD=SparseArray[PadRight[DiagonalMatrix[iTEBD[[1,2]]],{\[Chi] \[Chi]D}]];
\[Lambda]RD=SparseArray[PadRight[DiagonalMatrix[iTEBD[[2,2]]],{\[Chi] \[Chi]D}]];

Hint=(Partition[#,2]&/@(Partition[#,2]&/@H));
\[Lambda]LD=SparseArray[DiagonalMatrix[iTEBD[[3,2]]]];
\[Lambda]1D=SparseArray[DiagonalMatrix[iTEBD[[1,2]]]];
\[Lambda]2D=SparseArray[DiagonalMatrix[iTEBD[[2,2]]]];
\[Lambda]RD=SparseArray[DiagonalMatrix[iTEBD[[3,2]]]];
(* First make 3 spin matrix  *)
\[CapitalSigma]=Flatten[Flatten[\[Lambda]LD.Transpose[iTEBD[[1,1]],{2,1,3}].\[Lambda]1D.Transpose[iTEBD[[2,1]],{2,1,3}].\[Lambda]2D.Transpose[iTEBD[[3,1]],{2,1,3}].\[Lambda]RD,{{1},{5},{2,3,4}}].Hint,{{3,1},{4,5,2}}];
(*  Perform SVD of the three spin matrix as 1-2 spins *)
{X,\[Lambda]temp,YT}=SingularValueDecomposition[\[CapitalSigma]]; 
\[Lambda]temp=(Diagonal[\[Lambda]temp])[[1;;\[Chi]]]; (* Truncated values *)
norm1=Total[\[Lambda]temp^2];
iTEBD[[1,2]]=SparseArray[\[Lambda]temp/Sqrt[norm1]];
\[Lambda]1D=DiagonalMatrix[iTEBD[[1,2]]];
(* Extract the tensors of the left spin *)
\[Lambda]LDi=SparseArray[PseudoInverse[Normal[\[Lambda]LD]]];
iTEBD[[1,1]]=SparseArray[Chop[(\[Lambda]LDi.#&)/@(Partition[X,{\[Chi],\[Chi]}][[All,1]])]];
(* Now rearrange right matrix to represent 2 spins as 1-1, multiplying before by the new \[Lambda]1 *)
\[CapitalSigma]=Flatten[\[Lambda]1D.Transpose[Partition[Partition[ConjugateTranspose[YT],{\[Chi],\[Chi]}][[1,All]],spin],{2,3,1,4}],{{2,1},{3,4}}];
(* And get the SVD as a normal case *)
{X,\[Lambda]temp,YT}=SingularValueDecomposition[\[CapitalSigma]]; 
\[Lambda]temp=(Diagonal[\[Lambda]temp])[[1;;\[Chi]]]; (* Truncated values *)
norm2=Total[\[Lambda]temp^2];
iTEBD[[2,2]]=SparseArray[\[Lambda]temp/Sqrt[norm2]];
(* The center tensor we obtain taking out \[Lambda]1 *) 
\[Lambda]1Di=SparseArray[PseudoInverse[Normal[\[Lambda]1D]]];
iTEBD[[2,1]]=SparseArray[Chop[(\[Lambda]1Di.#&)/@(Partition[X,{\[Chi],\[Chi]}][[All,1]])]];
(* The right tensor needs the inverse right lambda to fit *)
\[Lambda]RDi=SparseArray[PseudoInverse[Normal[\[Lambda]RD]]];
iTEBD[[3,1]]=SparseArray[Chop[(#.\[Lambda]RDi&)/@(Partition[ConjugateTranspose[YT],{\[Chi],\[Chi]}][[1,All]])]];
2-norm1-norm2
]


SetAttributes[iTEBD4QGate,HoldFirst];
iTEBD4QGate[iTEBD_,H_]:=
Module[{spin,\[Chi],\[Lambda]LD,\[Lambda]1D,\[Lambda]2D,\[Lambda]3D,\[Lambda]RD,\[CapitalSigma],X,YT,\[Lambda]temp,\[Lambda]RDi,\[Lambda]LDi,\[Lambda]1Di,\[Lambda]2Di,norm1,norm2,norm3,Hint},
{spin,\[Chi]}=Dimensions[iTEBD[[1,1]]][[1;;2]];
Hint=Partition[#,spin]&/@(Partition[#,spin]&/@(Partition[#,spin]&/@H));
\[Lambda]LD=SparseArray[DiagonalMatrix[iTEBD[[4,2]]]];
\[Lambda]1D=SparseArray[DiagonalMatrix[iTEBD[[1,2]]]];
\[Lambda]2D=SparseArray[DiagonalMatrix[iTEBD[[2,2]]]];
\[Lambda]3D=SparseArray[DiagonalMatrix[iTEBD[[3,2]]]];
\[Lambda]RD=SparseArray[DiagonalMatrix[iTEBD[[4,2]]]];
(* First make 4 spin matrix  \[Alpha]ijkl\[Beta] HilIL=\[Alpha]jk\[Beta]il HilIL=\[Alpha]jk\[Beta]IL*)
\[CapitalSigma]=Flatten[Flatten[\[Lambda]LD.Transpose[iTEBD[[1,1]],{2,1,3}].\[Lambda]1D.Transpose[iTEBD[[2,1]],{2,1,3}].\[Lambda]2D.Transpose[iTEBD[[3,1]],{2,1,3}].\[Lambda]3D.Transpose[iTEBD[[4,1]],{2,1,3}].\[Lambda]RD,{{1},{6},{2,3,4,5}}].Hint,{{3,1},{4,5,6,2}}];
(*  Perform SVD of the three spin matrix as 1-2 spins *)
{X,\[Lambda]temp,YT}=SingularValueDecomposition[\[CapitalSigma]]; 
\[Lambda]temp=(Diagonal[\[Lambda]temp])[[1;;\[Chi]]]; (* Truncated values *)
norm1=Total[\[Lambda]temp^2];
iTEBD[[1,2]]=\[Lambda]temp/Sqrt[norm1];
\[Lambda]1D=SparseArray[DiagonalMatrix[iTEBD[[1,2]]]];
(* Extract the tensors of the left spin *)
\[Lambda]LDi=SparseArray[PseudoInverse[Normal[\[Lambda]LD]]];
iTEBD[[1,1]]=SparseArray[Chop[(\[Lambda]LDi.#&)/@(Partition[X,{\[Chi],\[Chi]}][[All,1]])]];
(* Now rearrange right matrix to represent 3 spins, multiplying before by the new \[Lambda]1 *)
\[CapitalSigma]=Flatten[\[Lambda]1D.Transpose[Partition[ConjugateTranspose[YT],{\[Chi],SpinDimension^2 \[Chi]}][[1,All]],{2,1,3}],{{2,1},{3}}];
(* And get the SVD as a normal case *)
{X,\[Lambda]temp,YT}=SingularValueDecomposition[\[CapitalSigma]]; 
\[Lambda]temp=(Diagonal[\[Lambda]temp])[[1;;\[Chi]]]; (* Truncated values *)
norm2=Total[\[Lambda]temp^2];
iTEBD[[2,2]]=\[Lambda]temp/Sqrt[norm2];
\[Lambda]2D=SparseArray[DiagonalMatrix[iTEBD[[2,2]]]];(* The center tensor we obtain taking out \[Lambda]1 *) 
\[Lambda]1Di=SparseArray[PseudoInverse[Normal[\[Lambda]1D]]];
iTEBD[[2,1]]=SparseArray[Chop[(\[Lambda]1Di.#&)/@(Partition[X,{\[Chi],\[Chi]}][[All,1]])]];
(* Final decomposition *)
\[CapitalSigma]=Flatten[\[Lambda]2D.Transpose[Partition[Partition[ConjugateTranspose[YT],{\[Chi],\[Chi]}][[1,All]],SpinDimension],{2,3,1,4}],{{2,1},{3,4}}];
(* And get the SVD as a normal case *)
{X,\[Lambda]temp,YT}=SingularValueDecomposition[\[CapitalSigma]]; 
\[Lambda]temp=(Diagonal[\[Lambda]temp])[[1;;\[Chi]]]; (* Truncated values *)
norm3=Total[\[Lambda]temp^2];
iTEBD[[3,2]]=\[Lambda]temp/Sqrt[norm3];
(* The center tensor we obtain taking out \[Lambda]1 *) 
\[Lambda]2Di=SparseArray[PseudoInverse[Normal[\[Lambda]2D]]];
iTEBD[[3,1]]=SparseArray[Chop[(\[Lambda]2Di.#&)/@(Partition[X,{\[Chi],\[Chi]}][[All,1]])]];
(* The right tensor needs the inverse right lambda to fit *)
\[Lambda]RDi=SparseArray[PseudoInverse[Normal[\[Lambda]RD]]];
iTEBD[[4,1]]=SparseArray[Chop[(#.\[Lambda]RDi&)/@(Partition[ConjugateTranspose[YT],{\[Chi],\[Chi]}][[1,All]])]];
3-norm1-norm2-norm3
]


SetAttributes[iTEBDEvolution,HoldAll];
iTEBDEvolution[Hams_,iTEBD_]:=Module[{error},
(* If[Length[Hams]!=Length[iTEBD],Return[-999]]; *)
Switch[Length[iTEBD],
2,Evolution2Sites[Hams,iTEBD],
3,Evolution3Sites[Hams,iTEBD],
4,Evolution4Sites[Hams,iTEBD]
]
]


SetAttributes[Evolution2Sites,HoldAll];
Evolution2Sites[Hams_,iTEBD_]:=Module[{error},
error=0;
error+=iTEBD2QGate[iTEBD,Hams[[2]]];
iTEBD=RotateRight[iTEBD,1];
error+=iTEBD2QGate[iTEBD,Hams[[2]]];
error+=iTEBD1QGate[iTEBD,Hams[[1]]];
error+=iTEBD2QGate[iTEBD,Hams[[2]]];
iTEBD=RotateLeft[iTEBD,1];
error+=iTEBD2QGate[iTEBD,Hams[[2]]];
error
]


SetAttributes[Evolution3Sites,HoldAll];
Evolution3Sites[Hams_,iTEBD_]:=Module[{error},
error=0;
error+=iTEBD3QGate[iTEBD,Hams[[2]]];
iTEBD=RotateRight[iTEBD,1];
error+=iTEBD3QGate[iTEBD,Hams[[2]]];
iTEBD=RotateRight[iTEBD,1];
error+=iTEBD3QGate[iTEBD,Hams[[2]]];
error+=iTEBD1QGate[iTEBD,Hams[[1]]];
error+=iTEBD3QGate[iTEBD,Hams[[2]]];
iTEBD=RotateLeft[iTEBD,1];
error+=iTEBD3QGate[iTEBD,Hams[[2]]];
iTEBD=RotateLeft[iTEBD,1];
error+=iTEBD3QGate[iTEBD,Hams[[2]]];
error
]


SetAttributes[Evolution4Sites,HoldAll];
Evolution4Sites[Hams_,iTEBD_]:=Module[{error},
error=0;
error+=iTEBD4QGate[iTEBD,Hams[[2]]];
iTEBD=RotateRight[iTEBD,1];
error+=iTEBD4QGate[iTEBD,Hams[[2]]];
iTEBD=RotateRight[iTEBD,1];
error+=iTEBD4QGate[iTEBD,Hams[[2]]];
iTEBD=RotateRight[iTEBD,1];
error+=iTEBD4QGate[iTEBD,Hams[[2]]];
error+=iTEBD1QGate[iTEBD,Hams[[1]]];
error+=iTEBD4QGate[iTEBD,Hams[[2]]];
iTEBD=RotateLeft[iTEBD,1];
error+=iTEBD4QGate[iTEBD,Hams[[2]]];
iTEBD=RotateLeft[iTEBD,1];
error+=iTEBD4QGate[iTEBD,Hams[[2]]];
iTEBD=RotateLeft[iTEBD,1];
error+=iTEBD4QGate[iTEBD,Hams[[2]]];
error
]


SetAttributes[Expectation1O,HoldRest];
Expectation1O[Operator_,iTEBD_]:=Module[{Mdown,Mup,value,numTensors,tensor},
value=0;
numTensors=Length[iTEBD];
tensor[n_]:=Mod[n,numTensors]+1;
Do[
Mup=Flatten[DiagonalMatrix[iTEBD[[tensor[index-1],2]]].Transpose[(Operator.iTEBD[[tensor[index],1]]),{2,1,3}].DiagonalMatrix[iTEBD[[tensor[index],2]]]];
Mdown=Flatten[DiagonalMatrix[iTEBD[[tensor[index-1],2]]].Transpose[Conjugate[iTEBD[[tensor[index],1]]],{2,1,3}].DiagonalMatrix[iTEBD[[tensor[index],2]]]];
value+=Mdown.Mup
,{index,1,numTensors}];
Chop[value/numTensors]
]


SetAttributes[iTEBDCorrelationList,HoldFirst];iTEBDCorrelationList[iTEBD_,Operator1_,Operator2_,distance_]:=Module[{numTensors,M,value,tensor,temp,SpinDimension},
numTensors=Length[iTEBD];
SpinDimension=Length[iTEBD[[1,1]]];
tensor[n_]:=Mod[n,numTensors]+1;
value=Array[0&,distance];
(* This will do a loop over the different tensors in the iTEBD and average the expectation value *)
Do[
(* First prepare the initial matrix with the action of the Operator1 on the starting tensor *)
M=SparseArray[DiagonalMatrix[iTEBD[[tensor[start],2]]]].Sum[ConjugateTranspose[iTEBD[[tensor[start],1,i]]].(SparseArray[DiagonalMatrix[iTEBD[[tensor[start-1],2]]^2]]).((Operator1.iTEBD[[tensor[start],1]])[[i]]),{i,1,SpinDimension}].SparseArray[DiagonalMatrix[iTEBD[[tensor[start],2]]]];
(* The expectation value is added a table as a function of distance *)
value+=Table[
(* First we calculate the expectation value using Operator2 *)
temp=Tr[SparseArray[DiagonalMatrix[iTEBD[[tensor[start+dist],2]]]].Sum[ConjugateTranspose[iTEBD[[tensor[start+dist],1,i]]].M.((Operator2.iTEBD[[tensor[start+dist],1]])[[i]]),{i,1,SpinDimension}].SparseArray[DiagonalMatrix[iTEBD[[tensor[start+dist],2]]]]];
(* Now almost the same computation but for the following iteration, without the Operator2. The last computation is useless... *)
M=SparseArray[DiagonalMatrix[iTEBD[[tensor[start+dist],2]]]].Sum[ConjugateTranspose[iTEBD[[tensor[start+dist],1,i]]].M.iTEBD[[tensor[start+dist],1,i]],{i,1,SpinDimension}].SparseArray[DiagonalMatrix[iTEBD[[tensor[start+dist],2]]]];
temp
,{dist,1,distance}];

,{start,0,numTensors-1}];

Chop[value/numTensors]
]


SetAttributes[iTEBDFidelity,HoldFirst];
iTEBDFidelity[iTEBD1_,iTEBD2_]:=Module[{numTensors,\[Rho]1,\[Rho]2,GL,GR,evs,egs},
numTensors=Length[iTEBD1];
If[numTensors!=Length[iTEBD2],Return[-1]];

GL=SparseArray[DiagonalMatrix[iTEBD1[[numTensors,2]]]];
GL=Flatten[Fold[#1.Transpose[iTEBD1[[#2,1]],{2,1,3}].SparseArray[DiagonalMatrix[iTEBD1[[#2,2]]]]&,GL,Range[1,numTensors]],Append[{#}&/@Range[2,numTensors+1],{1,numTensors+2}]];
GR=Transpose[GL,Range[2,numTensors+1]~Join~{1}];
\[Rho]1=Flatten[GL.GR,{Range[1,numTensors],Range[numTensors+1,2 numTensors]}];

GL=SparseArray[DiagonalMatrix[iTEBD2[[numTensors,2]]]];
GL=Flatten[Fold[#1.Conjugate[Transpose[iTEBD2[[#2,1]],{2,1,3}]].SparseArray[DiagonalMatrix[iTEBD2[[#2,2]]]]&,GL,Range[1,numTensors]],Append[{#}&/@Range[2,numTensors+1],{1,numTensors+2}]];
GR=Transpose[GL,Range[2,numTensors+1]~Join~{1}];
\[Rho]2=Flatten[GL.GR,{Range[1,numTensors],Range[numTensors+1,2 numTensors]}];

{evs,egs}=Eigensystem[\[Rho]1];
GL=ConjugateTranspose[egs].DiagonalMatrix[Sqrt[evs]].egs;
{evs,egs}=Eigensystem[GL.\[Rho]2.GL];
GR=ConjugateTranspose[egs].DiagonalMatrix[Sqrt[evs]].egs;
Tr[GR]^2
]


iTEBDentropy[\[Lambda]_]:=-Sum[If[\[Lambda][[n]]>0,\[Lambda][[n]]^2Log[2,\[Lambda][[n]]^2],0],{n,1,Length[\[Lambda]]}];
iTEBDentropyList[TEBD_]:=Table[{n,iTEBDentropy[TEBD[[n,2]]]},{n,1,Length[TEBD]}]
iTEBDentropyAverage[TEBD_]:=Mean[iTEBDentropyList[TEBD][[All,2]]]
